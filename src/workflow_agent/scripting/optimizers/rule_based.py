# src/workflow_agent/scripting/optimizers/rule_based.py
import re
import logging
from typing import Dict, Any, List, Optional

logger = logging.getLogger(__name__)

# Define optimization rules
OPTIMIZATION_RULES = [
    # Improve error handling
    (
        r'(set -e\n)',
        r'\1# Add better error handling\nset -o pipefail\n\nerror_exit() {\n    echo "ERROR: $1" >&2\n    exit 1\n}\n\n'
    ),
    
    # Add logging function
    (
        r'(#!/usr/bin/env bash\n)',
        r'\1\n# Add standardized logging\nlog_message() {\n    echo "[$(date "+%Y-%m-%d %H:%M:%S")] $1"\n}\n\n'
    ),
    
    # Improve package installation
    (
        r'apt-get install -y ([a-zA-Z0-9_\-]+)',
        r'if ! command -v \1 &>/dev/null; then\n    apt-get update\n    apt-get install -y \1 || error_exit "Failed to install \1"\nfi'
    ),
    
    # Add command error checking
    (
        r'([^|&;]+?)((?:\s*[|&;]\s*)|$)',
        lambda m: f"{m.group(1)} || error_exit \"Command failed: {m.group(1).strip()}\" {m.group(2) if m.group(2) else ''}"
        if not (
            "error_exit" in m.group(1) or 
            "if " in m.group(1) or 
            "fi" in m.group(1) or
            "echo" in m.group(1) or 
            m.group(1).strip().startswith("#") or
            "||" in m.group(1) or
            len(m.group(1).strip()) < 5
        ) else m.group(0)
    ),
    
    # Add idempotence for directory creation
    (
        r'mkdir\s+([^-])',
        r'mkdir -p \1'
    ),
    
    # Add cleanup trap
    (
        r'(#!/usr/bin/env bash\n(?:.*\n)*)',
        lambda m: m.group(1) + (
            "\n# Add cleanup trap\ncleanup() {\n    # Add cleanup actions here\n    echo \"Cleanup complete\"\n}\ntrap cleanup EXIT\n\n" 
            if "trap" not in m.group(1) else ""
        )
    ),
    
    # Add script header with documentation
    (
        r'(#!/usr/bin/env bash\n)',
        r'\1# ============================================================================\n# Script generated by Workflow Agent\n# Purpose: Script for automation task\n# ============================================================================\n\n'
    )
]

async def optimize_script(
    script: str,
    state: Optional[Dict[str, Any]] = None,
    system_context: Optional[Dict[str, Any]] = None,
    history: Optional[List[Dict[str, Any]]] = None,
    statistics: Optional[Dict[str, Any]] = None
) -> str:
    """
    Optimize a script using rule-based patterns.
    
    Args:
        script: Script content to optimize
        state: Optional workflow state
        system_context: Optional system context
        history: Optional execution history
        statistics: Optional execution statistics
        
    Returns:
        Optimized script
    """
    if not script:
        logger.warning("Empty script provided to optimizer")
        return script
    
    logger.info("Optimizing script with rule-based optimizer")
    
    # Apply each optimization rule
    optimized = script
    
    for pattern, replacement in OPTIMIZATION_RULES:
        try:
            if callable(replacement):
                optimized = re.sub(pattern, replacement, optimized, flags=re.MULTILINE)
            else:
                optimized = re.sub(pattern, replacement, optimized, flags=re.MULTILINE)
        except Exception as e:
            logger.error(f"Error applying optimization rule: {e}")
    
    # Add target and action specific optimizations if state is available
    if state:
        target = state.get("target_name", "")
        action = state.get("action", "")
        
        # Specific optimizations for postgres
        if target == "postgres" and action == "install":
            optimized = optimized.replace(
                "apt-get install -y postgresql",
                "if ! command -v psql &>/dev/null; then\n"
                "    apt-get update\n"
                "    apt-get install -y postgresql postgresql-contrib\n"
                "    log_message \"Installed PostgreSQL\"\n"
                "else\n"
                "    log_message \"PostgreSQL already installed\"\n"
                "fi"
            )
    
    # Apply system-specific optimizations
    if system_context:
        # Use appropriate package manager
        if "package_managers" in system_context:
            pkg_managers = system_context["package_managers"]
            primary = pkg_managers.get("primary", "")
            
            if primary == "apt":
                optimized = re.sub(
                    r'(apt-get install -y [^|&;]+)',
                    r'apt-get update && \1',
                    optimized
                )
            elif primary == "yum":
                optimized = optimized.replace("apt-get install", "yum install")
                optimized = optimized.replace("apt-get update", "yum check-update")
    
    # Count the number of optimizations applied
    changes = len([1 for a, b in zip(script.splitlines(), optimized.splitlines()) if a != b])
    if changes > 0:
        logger.info(f"Applied {changes} optimizations to the script")
    else:
        logger.info("No optimizations applied to the script")
    
    return optimized